[Java并发编程的艺术](https://book.douban.com/subject/26591326/)

<!-- TOC -->

- [第一章 并发编程的挑战](#第一章-并发编程的挑战)
        - [上下文切换](#上下文切换)
        - [死锁](#死锁)
        - [资源限制的挑战](#资源限制的挑战)
- [Java并发机制的底层实现原理](#java并发机制的底层实现原理)
        - [volatile的应用](#volatile的应用)
        - [synchronized的实现原理与应用](#synchronized的实现原理与应用)
        - [原子操作的实现原理](#原子操作的实现原理)

<!-- /TOC -->

## 第一章 并发编程的挑战

并发编程的目的是为了让程序运行更快，但是不是启动更多线程就能让程序更大程度的运行，受限于上下文切换，死锁，硬件和软件的资源。

#### 上下文切换

单核处理器也是通过为每个线程分配cpu时间片来支持多线程执行代码。时间片是cpu分配个各个线程的时间，一般为十几毫秒，时间非常短，所以cpu不停的切换线程执行，就会感觉有多个线程同时执行。

CPU通过时间片分配算法来循环执行任务，任务切换时，保存上一个任务的状态，下次切回时可以继续加载这个任务的状态。保存到再加载的过程就是一次上下文切换。

减少上下文切换的方法：

`无锁并发编程`：多线程竞争锁时，会引起上下文切换，所以多线程处理数据时，可以用一些办法来避免使用锁，如将数据用ID进行Hash算法后分段，不同的线程处理不同段的数据。

`CAS算法`：Java的Atomic包使用CAS算法来更新数据，而不需要加锁。

`使用最少线程`：避免创建不需要的线程，比如任务很少，但是创建了很多线程来处理，这样会造成大量线程都处于等待状态。

`协程`：在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换。

#### 死锁

避免死锁的常见方法:
- 避免一个线程同时获取多个锁。
- 避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源。
- 尝试使用定时锁，使用tryLock(timeout)来替代使用内部锁机制。
- 对于数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败。

#### 资源限制的挑战

资源限制：进行并发编程时，程序的执行速度受限于计算机硬件资源或软件资源的限制。

并发编程将代码执行速度加速的原则是将代码中串行执行的部分变成并发执行，但是如果某段串行的代码并发执行，但是因为受限于资源的限制，仍然在串行执行，这时候程序不仅不会执行加快，反而会更慢，因为增加了上下文切换和资源调度的时间

对于硬件资源限制，可以考虑使用集群并行执行程序，既然单机的资源有限制，那么就让程序在多机上运行。

对于软件资源限制，可以考虑使用资源池将资源复用。

## Java并发机制的底层实现原理

#### volatile的应用

#### synchronized的实现原理与应用

#### 原子操作的实现原理