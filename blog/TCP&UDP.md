---
title: TCP & UDP
updated: 2018/9/28 20:46:25
tags:
- 计算机网络
- TCP
categories:
- 计算机网络
---

![tcp](http://ww1.sinaimg.cn/large/006QFgWMgy1fwcn7lnlrgj32l61k3kjl.jpg)

## TCP&UDP概述

传输层位于应用层和网络层之间，传输层负责向应用层提供通信服务，同时接受来自网络层的服务。它属于面向通信的最高层，也是用户功能的最底层。传输层的主要任务是为两个主机之间进程与进程通信提供服务。也就是说端到端的通信是进程之间的通信，不同进程间可以通过一些粗粒度的通信机制来交换数据，例如：管道`pipe`（有名管道`FIFO`），信号量`semophore `，消息队列`message queue`，信号`sinal`，套接字`socket`。

传输层协议提供两种不同两种类型的服务:无连接的服务（UDP）和面向连接的服务(TCP)。

<!-- more --> 

使用无连接服务时，源进程将他的报文分割成大小可被传输层接受的数据块，并将这些数据块逐个交付传输层。传输层视这些数据块为独立的数据块，之间没有联系。在传输的过程中，这些报文可能丢失，也有可能以无序的方式全部到达目的进程。没有哪种流量控制，差错控制或拥塞控制策略能有效实施。

使用面向连接的服务时，客户端和服务器首先要建立一条连接，报文的传输依赖这条连接，在传输完成之后需要断开连接。因此不可避免地增加了许多开销，如确认，流量控制，连接管理等。


## UDP

UDP是一种无连接的，不可靠的传输协议，使用端口号来进行进程到进程的通信。

主要特点：
* 无连接的。 发送数据前不需要建立连接，发送完成之后也不需要释放，减少了开销和发送数据的时延。
* 尽最大努力交付，缺少差错控制。 不能保证数据的完全到达目的进程
* 面向报文。 发送方传输层从应用层收到报文，会将报文原封不动的交给IP层（会加上UDP首部）。
* 没有拥塞控制。
* 支持一对一，一对多，多对一，多对多的交互通信。
* 首部开销小。 只有18个字节，TCP首部20个字节。

## TCP

TCP是一种面向连接的，可靠的传输协议。在传输数据之前需要建立连接。

主要特点：
* TCP是面向连接的运输层的协议。
* 每一条TCP只能有两个端点。只能是点对点的。
* 提供可靠的交付服务。通过TCP传输的数据无差错，不丢失，不重复，并且按顺序到达。
* 提供全双工的通信。
* 面向字节流。
* 流量控制，差错控制，拥塞控制


### 三次握手

TCP是以全双工的方式进行传输数据。两个端口建立连接之后，能够同时向对方发送报文段，传输数据之前，双方必须对通信进行初始化，并得到对方认可。

建立TCP连接的过程

![tcp](http://ww1.sinaimg.cn/large/006QFgWMgy1fwcn8augspj30qa0dy0tu.jpg)

首先客户端A创建`传输控制模块TCB`，然后，在建立TCP连接时，向B发出连接请求报文段，这是首部的`SYN=1`,同时初始化序号`seq=x`。TCP客户端进入`SYN-SENT(同步已发送)`状态。

B接收到请求连接的报文段后，会向A发送确认报文段，确认报文段中`SYN=1,ACK=1`，确认号是`ack=x+1`，同时自己初始化序号`seq=y`。TCP服务器进程进人`SYN-RCVD（同步收到）`状态。

客户端收到B的确认后，将确认报文置为`ACK=1`，确认号`ack=y+1`，自己的序号`seq=x+1`,向B发出确认。这时TCP连接已经建立，A进入`ESTABLISHED(已建立连接)`状态。

当B收到A的确认后，也进入`ESTABLISHED(已建立连接)`状态。

最后一次确认时为了防止已经失效的连接请求报文段突然又传到了B，因而产生错误。

所谓“已失效的连接请求报文段”是这样产生的。考虑一种正常情况。A发出连接请求，但因连接请求丢失而未收到确认。于是A再次重传一次连接请求。后来收到了确认建立了连接。数据传输完毕后，就释放了连接。A发送了两个连接请求的报文段，其中第一个丢失，第二个到达了 B。没有“已失效的连接请求报文段”。

现假定出现一种异常情况，即A发出的第一个连接请求报文段并没有丢失，而是在某些网络节点长时间滞留了，以致延误到连接释放以后的某个时间才到B。本来这是一个已失效的报文段。但是B收到此失效的连接请求报文段后，就误认为是A有发出一次新的连接请求。于是就向A发出确认报文段，同意建立连接。假定不采用三次握手，那么只要B发出确认，新的连接就建立了。

由于现在A并没有发出建立连接的请求，因此不会理睬B的确认，也不会向B发送数据。但B却以为新的运输连接已经建立了，并一直等待A发来数据。B的许多资源就这样拜拜浪费了。

采用三次握手的办法可以防止上述现象的发生。例如在刚才的情况下， A不会向B的确认发出确认。B由于收不到确认，就知道A并没有要求建立连接。

### 四次挥手

释放TCP连接的过程

![tcp](http://ww1.sinaimg.cn/large/006QFgWMgy1fwcn8y6s1qj30r10gzabn.jpg)

客户端A的 TCP 进程先向服务端发出连接释放报文段，并停止发送数据，主动关闭TCP连接。释放连接报文段中 `FIN=1`，序号为 `seq=u`，该序号等于前面已经传送过去的数据的最后一个字节的序号加1。这时，A进入`FIN—WAIT-1` (终止等待1)状态，等待B的确认。

B收到连接释放报文段后即发出确认释放连接的报文段，该报文段中`ACK=1`，确认号`ack=u+1`，其自己的序号为v，该序号等于B前面已经传送过的数据的最后一个字节的序号加1。然后B进入`CLOSE—WAIT(关闭等待)`状态，此时TCP服务器进程应该通知上层的应用进程，因而A到B这个方向的连接就释放了，这时TCP处于半关闭状态，即A已经没有数据要发了，但B若发送数据，A仍要接受，也就是说从B到A这个方向的连接并没有关闭，这个状态可能会持续一些时间。这是TCP连接释放的第二次挥手。

A收到B的确认后，就进入了`FIN—WAIT(终止等待2)`状态，等待B发出连接释放报文段，如果B已经没有要向A发送的数据了，其应用进程就通知TCP释放连接。这时B发出的链接释放报文段 `FIN=1`，确认号还必须重复上次已发送过的确认号，即`ack=u+1`，序号`seq=w`，因为在半关闭状态B可能又发送了一些数据，因此该序号为半关闭状态发送的数据的最后一个字节的序号加1。这时B进入`LAST—ACK(最后确认)`状态，等待A的确认，这是TCP连接的第三次挥手。

A收到B的连接释放请求后，必须对此发出确认。确认报文段中`ACK=1`，确认号`ack=w+1`，而自己的序号`seq=u+1`，而后进入`TIME—WAIT(时间等待)`状态。这时候，TCP连接还没有释放掉，必须经过时间等待计时器设置的时间`2MSL`后，A才进入`CLOSED`状态，时间MSL叫做最长报文寿命，因此从A进入`TIME—WAIT`状态后，`2MSL`后才能进入到`CLOSED`状态，而B只要收到了A的确认后，就进入了`CLOSED`状态。二者都进入`CLOSED`状态后，连接就完全释放了，这是TCP连接的第四次挥手。

需要四次挥手为了保证A发送的最后一个ACK报文段能够到达B。即最后这个确认报文段很有可能丢失，那么B会超时重传，然后A再一次确认，同时启动`2MSL`计时器，如此下去。如果没有等待时间，发送完确认报文段就立即释放连接的话，B就无法重传了（连接已被释放，任何数据都不能出传了），因而也就收不到确认，就无法按照步骤进入`CLOSE`状态，即必须收到确认才能`close`。

`2MSL`防止“已失效的连接请求报文段”出现在连接中。经过2MSL，那些在这个连接持续的时间内，产生的所有报文段就可以都从网络中消失。即在这个连接释放的过程中会有一些无效的报文段滞留在楼阁结点，但是呢，经过2MSL这些无效报文段就肯定可以发送到目的地，不会滞留在网络中。这样的话，在下一个连接中就不会出现上一个连接遗留下来的请求报文段了。


## 参考
- [计算机网络(第七版)](https://book.douban.com/subject/26960678/)
- [TCPIP协议族](https://book.douban.com/subject/5386194/)